[back](00.main.md)
# Data Structures

# Intro

The term **data structure** in C basically involves how data is structured in memory using pointers.

# Abstract Data Types

**Abstract data types** have some properties but it can have underlying implementations which are created by the programmer (based on how the programmer wants to implement it).

## Queue

A **queue** is a type of data structure which uses a FIFO (First in First out) property.

It consists of 2 functions/operations:

- **Enqueue:** adding data to the end of the queue.
- **Dequeue:** removing the first data in the queue.

## Stack

A **stack** is another abstract datatype where a new data is stacked above an old one. Imagine stacking trays above each other and asking the user to pick a tray, he/she will probably pick the highest tray or imagine how your notifications are stacked. Therefore, it uses a LIFO (Last in First Out) property.

Stack uses 2 operators:

- **Push:** basically adding an item to the top of the stack.
- **Pop:** removing an item from the top of the stack

# Data Structure

```c
const int CAPACITY = 50;

typedef struct
{
    person people[CAPACITY];
    int size;
}
stack;

```

# Allocating a new array populated with larger items than the original

![Screenshot (71).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(71).png)

In a computers memory, there are a lot of things stored. So if we want to add another item to an array, we can easily compromise another data in the memory.

![Screenshot (70).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(70).png)

In order to increase the population of an array, we can use the initial array as a pointer to a new array and then assign the values of the new array to the initial array.

![Screenshot (69).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(69).png)

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 10;
    list[1] = 15;
    list[2] = 20;

    int *tmp = malloc(4 * sizeof(int));
    if (tmp == NULL)
    {
        free(list);
        return 1;
    }
    for (int i = 0; i < 4; i++)
    {
        tmp[i] = list[i];
    }
    tmp[3] = 4;

    free(list);

    list = tmp;
    for (int i = 0; i < 3; i++)
    {
        printf("%i\n", list[i]);
    }

    free(list);
    return 0;
}
```

This can be simplified with the help of `realloc` function.

# `realloc`

`realloc` is a function used to re-allocate memory. It uses two Command Line Arguments (CLAs): the chunk of memory you want to update (grow or shrink) and what size you want. It automatically frees up your previous memory.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 10;
    list[1] = 15;
    list[2] = 20;

    int *tmp = realloc(list, 4 * sizeof(int));
    if (tmp == NULL)
    {
        free(list);
        return 1;
    }
    list = tmp;
    list[3] = 4;

    for (int i = 0; i < 3; i++)
    {
        printf("%i\n", list[i]);
    }

    free(list);
    return 0;
}
```

# Linked lists

The term **linked lists** basically describes a way of linking different variables in different locations in memory using pointers.

![Screenshot (73).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(73).png)

![Screenshot (74).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(74).png)

![Screenshot (75).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(75).png)

Here, the variable assigning one is pointed to the address of the variable assigning 2 and the variable assigning 2 is pointed to the address of the variable assigning 3. The variable assigning 3 is pointed to a null value, meaning it does not have to do anything (invalid pointer). Pointer (0x123) then stores all the items.

These rectangles can be seen as **nodes** - ****a container in code for storing values.

To implement this in codeğŸ‘‡ğŸ¾:

```c
typedef struct
{
    int number;
    node *next;
}
node;
```

`node *next` simply specifies the address of the next node. We canâ€™t just use the datatype called node though as itâ€™s not a traditional C datatype. We would have to declare the node datatype at the top. In that caseğŸ‘‡ğŸ¾:

```c
typedef struct node
{
    int number;
    struct node *next;
}
node;
```

![Screenshot (77).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(77).png)

![Screenshot (78).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(78).png)

![Screenshot (79).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(79).png)

![Screenshot (81).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(81).png)

This can be written in code asğŸ‘‡ğŸ¾:

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
    int number;
    struct node *next;
}
node;

int main(int argc, char *argv[])
{
    node *list = NULL;
    for (int i = 1; i < argc; i++)
    {
        int number = atoi(argv[i]);
        node *n = malloc(sizeof(node));
        if (n == NULL)
        {
            return 1;
        }
        (*n).number = number;
        (*n).next = NULL; //n->next = NULL means the same thing;
        n->next = list;
        list = n;
    }
    node *ptr = list;
    while (ptr != NULL)
    {
        printf("%i\n", ptr->number);
        ptr = ptr->next;
    }
    ptr = list;
    while (ptr != NULL)
    {
        node *next = ptr->next;
        free(ptr);
        ptr = next;
    }

}
```

## Nodes

In the context of data structures like linked lists and trees, a **node** is an individual element that holds data and a reference (or references) to other nodes. In a linked list, a node typically contains a value and a pointer to the next node. In a tree, a node holds a value and references to its child nodes.

## Downsides of Linked lists

- It uses twice the space as it not just stores a variable but a pointer to it.
- You canâ€™t index through the lists as they are located in different areas of the memory i.e. not contiguous.
- You canâ€™t use binary search algorithm for link lists.

# Binary search trees

As said before, in an array you cannot add more items if thereâ€™s no space which is what linked lists does. But you can use pointers which serve as branches to do and also arrange the numbers sequentiallyğŸ‘‡ğŸ¾:

![Screenshot (82).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(82).png)

This gives that dynamism as you can append or prepend more items and it uses binary search as its searching algorithm. To implement this in code you can start with a structğŸ‘‡ğŸ¾:

![Screenshot (83).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(83).png)

You can use recursion for this algorithmğŸ‘‡ğŸ¾:

![Screenshot (85).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(85).png)

## Disadvantages of the tree format

- It uses a lot of memory.
- Thereâ€™s a bit of perversion in it i.e. it can turn into linked lists if not approached well.

![Screenshot (86).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(86).png)

# Dictionary, Hashing

A **dictionary** is another abstract datatype consisting of key-value pairs. Key is what you use to look for something and value is what you find via the key. E.g. in a phonebook, the key is the name and the value is the number.

![Screenshot (87).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(87).png)

## Hashing

**Hashing** requires taking as input some value and outputting a simpler version. Hashing combines an array(vertically) and linked lists (horizontally). Application of arrays and linked lists to leverage the best of both worlds to achieve a $O(1)$ algorithm.

![In this example, we take an input of about 52 cards and output it into a smaller range as we reduce them.](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(88).png)

In this example, we take an input of about 52 cards and output it into a smaller range as we reduce them.

## Hash function

A **hash function** an algorithm/math/code that implements the idea of hashing. The hash function is used to know where to output items in a hash table.

![Screenshot (105).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(105).png)

![We created a node array of the alphabets and run the function `hash` to show the corresponding alphabets of the indexes.](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(106).png)

We created a node array of the alphabets and run the function `hash` to show the corresponding alphabets of the indexes.

## Hash tables

A **hash table** is an array of linked lists.

You can find most of the names in constant time ($O(1)$). For most of the characters you have constant time lookup. Itâ€™s faster than a linked list because you donâ€™t have to search every name and faster than an array because you donâ€™t need to do binary search

![Screenshot (89).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(89).png)

![Screenshot (91).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(91).png)

You can include 2nd or 3rd letters to increase the number of names with a constant search algorithm ğŸ‘‡ğŸ¾:

![Screenshot (92).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(92).png)

**Disadvantage:** it carries a huge amount of memory. The number of cells here alone is 26 x 26 x 26.

This is how we can represent these nodes in the treeğŸ‘‡ğŸ¾:

![Screenshot (96).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(96).png)

If we are using a one dimensional hash table, you can see that the items (in this case names) hash out to a particular numberğŸ‘‡ğŸ¾;

![Albus hashes out to 0 as it begins with â€˜Aâ€™.](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(97).png)

Albus hashes out to 0 as it begins with â€˜Aâ€™.

![Zacharias hashes out to 25 as it begins with â€˜Zâ€™.](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(98).png)

Zacharias hashes out to 25 as it begins with â€˜Zâ€™.

# Tri

A **tri** is a tree each of whose node is an array.

![Screenshot (99).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(99).png)

![Screenshot (100).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(100).png)

At the end of the name, you will need some algorithm to indicate that itâ€™s the end.

This can be repeated for other related names as wellğŸ‘‡ğŸ¾:

![This is a search for the names â€œHagridâ€ and â€œHarryâ€.](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(101).png)

This is a search for the names â€œHagridâ€ and â€œHarryâ€.

![This is a search for the words â€œheyâ€, â€œhelpâ€ and â€œhelloâ€.](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(103).png)

This is a search for the words â€œheyâ€, â€œhelpâ€ and â€œhelloâ€.

Its data structure can be written asğŸ‘‡ğŸ¾:

![Screenshot (102).png](Data%20Structures%2009ceec29c11e43b7ac9f09019a946abb/Screenshot_(102).png)

## Disadvantage

- It also takes a lot of space.